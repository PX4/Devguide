# 가난한 자의 샘플링 프로파일러

이 절에서는 프로파일링 평균 수치로 PX4 시스템 성능을 살펴보는 방법을 설명합니다.

## 접근

PSMP는 현재 스택을 추적하면서 샘플 값을 채취하기 위해 펌웨어 실행을 주기적으로 중단하며 동작하는 셸 스크립트입니다. 채취한 스택 추적 결과는 텍스트 파일에 넣습니다. 표본 데이터 채취가 끝나면(보통 몇시간 이상 걸림), 수집한 스택 추적 결과를 *접어둡니다*. *접어둔* 결과는 다른 텍스트 파일에 동일한 스택 추적 결과가 들어있지만, 서로 붙어있는 모든 유사 스택 추적 결과를 제외하고, 발생 횟수를 기록합니다. 접어둔 스택을 시각화 스크립트에 던져두는데 이 목적으로 우리가 사용하는 도구가 [FlameGraph - 오픈소스 스택 추적 시각화도구](http://www.brendangregg.com/flamegraphs.html)입니다.

## 기본 사용법

프로파일러 기본 사용법은 빌드 시스템에 있습니다. 예를 들면 다음 명령은 px4_fmu-v4pro 대상을 빌드한 후 추적 샘플 10000개를 만듭니다(필요한 경우 *FrameGraph*를 불러와서 경로를 추가하십시오).

    make px4_fmu-v4pro_default profile
    

샘플 채취 수를 조정하여 빌드 과정을 통제하고 싶다면 [구현](#implementation) 절을 살펴보십시오.

## 출력 내용 이해

예제 출력 화면은 아래에 있습니다(참고로 여기 화면이 대화식은 아닙니다):

![FlameGraph 예제](../../assets/flamegraph-example.png)

FlameGraph에서, 수평 단계는 스택 프레임을, 프레임의 높이는 샘플 채취 횟수에 비례합니다. 여기서 채취한 함수 실행 종료 횟수는 실행 주기 시간 길이에 비례합니다.

## 나타날 수 있는 문제

ad-hoc 솔루션으로 개발했기에 일부 문제가 있습니다. 사용중에 다음 내용을 확인하십시오:

* GDB가 제대로 동작하지 않으면, 스크립트는 GDB 발견에 실패하고 실행을 계속합니다. 이 경우, 명백하게 가용 스택이 나타나지 않습니다. 이 문제를 피하려면, 사용자는 최근 GDB 실행시 나타난 표준 오류 기록 파일 `/tmp/pmpn-gdberr.log`를 주기적으로 확인해야합니다. 나중에는 스크립트를 종료 코드로 문제를 나타내는 부분인 출력 동작없이 GDB를 실행하도록 수정할 예정입니다.

* 때로는 GDB가 스택 추적 표본 데이터를 수정하는 동안 GDB가 계속 멈춰있을 수가 있습니다. 이런 문제가 나타나면, 대상의 동작이 알 수 없는 이유로 끝납니다. 해결책은 스크립트를 일단 직접 멈추고 `--append` 옵션을 붙여 다시 실행하는 방법입니다. 나중에는 매번 GDB 실행시 강제로 제한 시간을 부여하도록 수정할 예정입니다.

* 다중 스레드 환경을 지원하지 않습니다. 단일 코어 임베디드 대상에서는 늘 하나의 스레드로만 실행하기 때문에 문제가 없습니다. 다만, 이런 제약 사항이 다른 프로그램과 프로파일러의 호환성을 떨어뜨립니다. 나중에는 스택 폴더에서 표본 데이터당 다중 스택 추적을 지원하도록 할 예정입니다.

## 구현 {#implementation}

스크립트는 `Debug/poor-mans-profiler.sh` 위치에 있습니다. 한번 실행하면 지정 시간 주기별로 지정 표본 데이터 수만큼 동작합니다. 수집 표본 데이터는 시스템 임시 디렉터리(보통 `/tmp`)에 텍스트 파일로 저장합니다. 표본 데이터 수집이 끝나면, 스크립트는 임시 디렉터리의 인접 파일에 저장한 출력파일 스택 폴더를 자동으로 호출합니다. 스택을 잘 접어두었다면, 스크립트는 *FrameGraph* 스크립트를 호출하고 관련 결과를 양방향 SVG 파일에 저장합니다. 모든 이미지 보기 프로그램이 이 그림 형식을 지원하지 않음을 참고하십시오. 웹 브라우저에서 결과 SVG 파일을 열어보시는 것이 좋습니다.

FlameGraph 스크립트 위치는 `PATH`에 두어야 합니다. 그렇지 않으면 PMSP를 실행할 수 없습니다.

PMSP는 스택 추적 표본 데이터 수집시 GDB를 활용합니다. 현재 `arm-none-eabi-gdb`를 활용하며, 다른 툴체인은 나중에 추가하겠습니다.

메모리 위치를 심볼에 대응할 수 있으려면, 스크립트에서 대상 하드웨어의 현재 실행 파일에 접근해야합니다. 이는 현재 실행중인 ELF 바이너리 위치를 가리키는 경로를 `--elf=<file>`에 대입하는 옵션의 도움을 받아 처리할 수 있습니다.

사용 예제:

```bash
./poor-mans-profiler.sh --elf=build/px4_fmu-v4_default/px4_fmu-v4_default.elf --nsamples=30000
```

참고로 매번 스크립트를 실행할 때 이전 스택 내용을 덮어씁니다. 이전 스택 내용을 덮어쓰기보다, 계속 뒤에 추가할 경우 `--append` 옵션을 사용하십시오:

```bash
./poor-mans-profiler.sh --elf=build/px4_fmu-v4_default/px4_fmu-v4_default.elf --nsamples=30000 --append
```

짐작하는대로, `--append` 옵션과 `--nsamples=0` 옵션은 대상에 모두 접근하지 않고도 스크립트로 하여금 SVG 파일만 다시 만들게끔합니다.

스크립트의 동작 방식을 더 자세하게 이해하려면 코드를 직접 살펴보십시오.

## 기여자

[Mark Callaghan과 Domas Mituzas](https://dom.as/2009/02/15/poor-mans-contention-profiling/)의 아이디어입니다.